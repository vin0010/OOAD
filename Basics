#This file contains my observations and notes about OOAD.

Simplicity
    The code should do exactly what's necessary, nothing more

For any problem, go for simpler solution, if it needs to be modified in some time again, go for a better design pattern since it will have make further modification easier(Fool me once, shame on you, fool me twice shame on me)

Using Design patterns in every place is not a good idea, use it in places where you are going to modify code more than once.

Design incrementally, Build incrementally(imagine constructing multiple houses in apartment, dont go for painting in the first place after finishing the one side wall).

Cohesion/coherence and coupling :
    Cohesion : All public methods of a class form a cohesive group. They should be related to each other, no random methods should be grouped to form a class
    Coupling : If one global variable is used by two objects, changing it in one place might affect other place too, avoid coupling as much as possible. Lot of things can go wrong when there are too much coupling in programming.
    Idea is to isolate the objects as muchh as possible to make it easier to maintain.
    Conclusion : Maximize Cohesion, minimize Coupling
    If tightly coupled, change becomes hard

    Orthogonal(ity) : two things are orthogonal when changing one doesnt impact another

Object should be like a black box, it should never expose whats its doing inside, you can only ask for help.

All fields of a class should be private

Data abstraction(implementation hiding)
    We do not know how objects works but we do know how to ask it to do something for us

Single responsibility
    Object should be responsible for only one thing

Delegation:
    Don't get the data, ask the object that has the data to do the work for you.
    

Getters and Setters are evil
    They reveal too much information about your object work,

Is-A relationship
    If you feel A is B then A can extend B

Template method pattern
    Do most of the work in super class and let sub classes do their custom work.
    If some of the customization follows a pattern, keep an public method which uses abstract method inside super class and let others use it,
    when sub classes extend super class they should implement that abstact method as well.
       Example
        abstract Worker
            public pay(){
                Money m = getAmountDue(); // super class can talk to subclass without 'directly' talking
                pay m;
            }
            abstact Money getAmountDue()
        Employee extends Worker:
            public Money getAmount due()
        Contractor extends Worker:
            public Money getAmount due()


Protected
    the reason protected exist is for template methods




You should be able to radically change the implementation of a class without impacting its clients.
    If my class is completely stand alone thing, I can change it the the it work at any time.
    How to think in such a way that objects are loosely coupled?
        How to write my system such a way that the above principle is followed properly? How to do this constant check?
        Objects are like two spies are passing message in a park bench without seeing each other. One put the paper other take it and move away but never worried about who sends the message.
        Even in future if the spy changes, another one will never care and only care about message and walk away.

        Think and add my thoughts here.







TODO
    bob martin clean code
    see https://leetcode.com/problems/two-sum/discuss/3/Accepted-Java-O(n)-Solution
    Difference between protected and private methods and when to use them
    Broad leaf commerce
    sprint features
